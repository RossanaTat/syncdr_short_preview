---
title: "ET Consultant Application - (DECID)"
format:
  html:
    code-fold: false
    code-line-numbers: false
    code-overflow: wrap
    code-width: 170
author: "Rossana Tatulli"
date: "2025-02-19"
editor: visual
---

# Introduction to {syncdr}

## Coding sample

The code provided below is extracted from an R package called {syncdr}, which I developed with the aim of optimizing file handling, directory comparison and synchronization in R. By incorporating {syncdr} into their workflow, users can achieve a more organized and up-to-date file system, simplifying the overall management and synchronization of directories.

This page includes the back-end code and the corresponding output of some of its key functions. In fact since the back-end code is not runnable on its own, the "Output" section serves as a practical example to demonstrate the functions in action without requiring you to run it yourself. For more details, visit the [official {syncdr} website](https://rossanatat.github.io/syncdr/), which I developed alongside the package itself.

Specifically, the functions showcased here are as follows:

-   `compare_directories()`, which inspects the synchronization status of files present in both directories as well as those exclusive to either directory

-   `display_sync_status()`, which allows to visualize the synchronization status in DT Table

-   `full_asym_sync_to_right()`, which allows to perform different actions such as copying, moving, and deleting files to keep directories synchronized depending on users needs

```{r, eval=FALSE}

#' Compare Two Directories for Synchronization Status
#'
#' This function compares two directories, typically referred to as 'left' and 'right', 
#' to determine their synchronization status at the file level.
#' The primary goal is to identify the synchronization status of files present 
#' in both directories and those exclusive to either directory.
#'
#'
#' @section Sync Status Types:
#' The synchronization status is determined for files present in both directories, 
#' as well as  for files exclusive to either directory.
#' It can be computed based on modification date only, content only, or both.
#'
#' For Common Files:
#' * When comparing by date: 'new', 'old', or 'same'.
#' * When comparing by date and content: 'new and different', 'new and same', 
#'   'old and different', 'old and same', 'same and different', or 'same and same'.
#' * When comparing by content only: 'different' or 'same'.
#'
#' For Non-Common Files:
#' * When comparing by date (or by date and content, or by content only): 
#' 'only in left' or 'only in right'.
#'
#' @param left_path Path to the left/first directory.
#' @param right_path Path to the right/second directory.
#' @param by_date Logical. If TRUE (default), compares directories based on 
#' the modification date of common files.
#' @param by_content Logical. If TRUE, compares directories based on the hashed 
#' content of common files. Default is FALSE
#' @param recurse If TRUE, fully recurses through subdirectories. 
#' If a positive integer, specifies the number of levels to recurse.
#' @param verbose Logical. If TRUE display additional info on the comparison process. 
#' Default is FALSE
#'
#' @return A list of class "syncdr_status" containing the following elements:
#'   - Non-common files: Paths and synchronization status of files exclusive 
#' to either directory.
#'   - Common files: Paths and synchronization status of files present in both directories.
#'   - Path of the left directory.
#'   - Path of the right directory.
#'
#' @export
#' @examples
#' # Compare directories with 'compare_directories()'
#' e <- toy_dirs()
#'
#' # Get left and right directories' paths
#' left  <- e$left
#' right <- e$right
#' compare_directories(left, right)
#' # Compare by date and content
#' compare_directories(left, right, by_content = TRUE)
#' # Compare by content only
#' compare_directories(left, right, by_content = TRUE, by_date = FALSE)
compare_directories <- function(left_path,
                                right_path,
                                recurse     = TRUE,
                                by_date     = TRUE,
                                by_content  = FALSE,
                                verbose     = getOption("syncdr.verbose")){

  # Ensure both directory paths exist
  stopifnot(exprs = {
    fs::dir_exists(left_path)
    fs::dir_exists(right_path)
  })

  # Retrieve file information for the left directory
  info_left <- directory_info(dir     = left_path,
                              recurse = recurse)

  # Retrieve file information for the right directory
  info_right <- directory_info(dir     = right_path,
                               recurse = recurse)

  # Merge directory information using a full join to retain all files
  join_info <- joyn::joyn(x                = info_left,
                          y                = info_right,
                          by               = "wo_root",  # Match files based on relative path
                          keep_common_vars = TRUE,
                          suffixes         = c("_left", "_right"),
                          match_type       = "1:1",  # Ensures one-to-one matches
                          reportvar        = ".joyn", # Column indicating match status
                          verbose          = FALSE)

  # Identify files that exist only in one of the directories
  non_common_files <- join_info |>
    fsubset(.joyn == "y" | .joyn == "x") |>  # Select unmatched files
    fselect(path_left, path_right) |>         # Keep relevant columns
    ftransform(sync_status = ifelse(          # Assign sync status
      (is.na(path_left) & !is.na(path_right)), "only in right",
      "only in left")
    )

  # Identify files that exist in both directories
  common_files <- join_info |>
    fsubset(.joyn == "x & y") |>  # Select matched files
    fselect(path_left,
            path_right,
            modification_time_left,
            modification_time_right)  # Keep modification times

  # Compare modification times if requested
  if (by_date) {
    compared_times <- compare_modification_times(common_files$modification_time_left,
                                                 common_files$modification_time_right)
    common_files   <- cbind(common_files,
                            compared_times) |>
      ftransform(sync_status      = sync_status_date,  # Update sync status based on dates
                 sync_status_date = NULL)
  }

  # Compare file contents if requested
  if (by_content) {

    # If comparing by date, first filter files marked as new
    if (by_date) {
      common_files <- common_files |>
        fsubset(is_new_left == TRUE | is_new_right == TRUE)
    }

    # Compare file contents
    compared_contents <- compare_file_contents(common_files$path_left,
                                               common_files$path_right,
                                               verbose = verbose)

    common_files <- cbind(common_files,
                          compared_contents) |>
      ftransform(sync_status         = sync_status_content,  # Update sync status based on content
                 sync_status_content = NULL)
  }

  # Create a structured output list
  sync_status = list(
    common_files     = common_files,  # Files that exist in both directories
    non_common_files = non_common_files,  # Files unique to one directory
    left_path        = left_path,  # Path to left directory
    right_path       = right_path  # Path to right directory
  )

  # Display directory structure if verbose mode is enabled
  if (verbose) {
    display_dir_tree(left_path,
                     right_path)
  }

  # Assign custom class for easier handling in other functions
  class(sync_status) <- "syncdr_status"

  return(sync_status)
}



```

```{r, eval=FALSE}

#' Display status of synchronization/comparison info between two directories in DT table
#'
#' @param sync_status_files object of `compare_directories()` output, 
#' either common_files or non_common_files
#' @param left_path A character string specifying the path to left directory.
#' @param right_path A character string specifying the path to right directory.
#' @return DT table showing the comparison between the two directories
#'         together with their synchronization status
#' @export
display_sync_status <- function(sync_status_files,
                                left_path,
                                right_path) {

  # clean display of paths
  sync_status_files <- sync_status_files |>
    fmutate(path_left = gsub(left_path, "", path_left)) |>
    fmutate(path_right = gsub(right_path, "", path_right))

  # Build DT table
  DT::datatable(sync_status_files,
                options = list(
                  pageLength = 10, # number of rows to display per page
                  columnDefs = list(
                    list(targets = grep("^is_", colnames(sync_status_files), value = TRUE),
                         createdCell = DT::JS(
                           "function(td, cellData, rowData, row, col) {
                            if (cellData === true) {
                              $(td).css({'background-color': '#F8F4FF'});
                            } else {
                              $(td).css({'background-color': '#F0F8FF'});
                            }
                          }"
                         )
                    ),
                    list(targets = grep("sync_status", colnames(sync_status_files), value = TRUE),
                         createdCell = DT::JS(
                           "function(td, cellData, rowData, row, col) {
                             if (cellData.includes('different content') ||
                                 cellData.includes('same date') ||
                                 cellData.includes('only in right')) {
                              $(td).css({'background-color': '#a9def9'});
                            } else {
                              $(td).css({'background-color': '#e4c1f9'});
                            }
                          }"
                         )
                    )
                  )
                )
  )

}

```

```{r, eval=FALSE}

#' Full asymmetric synchronization to right directory
#'
#' This function performs a full asymmetric synchronization of the right directory
#' based on the left directory. It includes the following synchronization steps 
#' (see Details below):
#'
#' * For common files:
#'   - If comparing by date only (`by_date = TRUE`): Copy files that are newer in 
#'   the left directory to the right directory.
#'   - If comparing by date and content (`by_date = TRUE` and `by_content = TRUE`): Copy files
#'   that are newer and different in the left directory to the right directory.
#'   - If comparing by content only (`by_content = TRUE`): Copy files that are different in the
#'   left directory to the right directory.
#' * Copy to the right directory those files that exist only in the left directory.
#' * Delete from the right directory those files that are exclusive in the right directory
#' (i.e., missing in the left directory)
#'
#' @param left_path Path to the left/first directory.
#' @param right_path Path to the right/second directory.
#' @param sync_status Object of class "syncdr_status", output of `compare_directories()`.
#' @param by_date Logical. If TRUE, synchronize based on file modification dates 
#' (default is TRUE).
#' @param by_content Logical. If TRUE, synchronize based on file contents (default is FALSE).
#' @param recurse Logical. If TRUE (default), files are copied to corresponding subdirectories
#'                in the destination folder. 
#'                If FALSE, files are copied to the top level of the destination folder
#'                without creating subdirectories if they do not exist.
#' @param force Logical. If TRUE (by default), 
#' directly perform synchronization of the directories. If FALSE, Displays a preview of actions
#' and prompts the user for confirmation before proceeding. 
#  Synchronization is aborted if the user does not agree.
#' @param backup Logical. If TRUE, creates a backup of the right directory before
#' synchronization. The backup is stored in the location specified by `backup_dir`.
#' @param backup_dir Path to the directory where the backup of the original right 
#' directory will be stored. If not specified, the backup is stored in temporary directory 
#' @param verbose logical. If TRUE, display directory tree before and after synchronization.
#' Default is FALSE
#' @return Invisible TRUE indicating successful synchronization.
#'
#' @export
#' @examples
#' # Create syncdr environment with toy directories
#' library(syncdr)
#' e <- toy_dirs()
#'
#' # Get left and right directories' paths
#' left  <- e$left
#' right <- e$right
#'
#' # Synchronize by date & content
#' # Providing left and right paths to directories, as well as by_date and content
#' full_asym_sync_to_right(left_path  = left,
#'                         right_path = right,
#'                         by_date    = FALSE,
#'                         by_content = TRUE)
#' # Providing sync_status object
#' #sync_status = compare_directories(left_path = left,
#' #                                   right_path = right)
#' #full_asym_sync_to_right(sync_status = sync_status)
full_asym_sync_to_right <- function(left_path   = NULL,
                                    right_path  = NULL,
                                    sync_status = NULL,
                                    by_date     = TRUE,
                                    by_content  = FALSE,
                                    recurse     = TRUE,
                                    force       = TRUE,
                                    backup      = FALSE,
                                    backup_dir  = "temp_dir",
                                    verbose     = getOption("syncdr.verbose")) {

  # --- Step 1: Display directory structure before synchronization ----
  if (verbose == TRUE) {

    # Display message about pre-synchronization directory structure
    style_msgs(color_name = "blue",
               text = "Directories structure BEFORE synchronization:\n")

    # Display the actual directory structure of both left and right directories
    display_dir_tree(path_left  = left_path,
                     path_right = right_path)
  }

  # --- Step 2: Check validity of arguments ----
  # Ensure correct combination of inputs
  if(!(
    is.null(sync_status) && !is.null(left_path) && !is.null(right_path) ||
       !is.null(sync_status) && is.null(left_path) && is.null(right_path)
    )) {

    style_msgs(color_name = "purple",
               text = "Incorrect arguments specification!\n")

    cli::cli_abort("Either sync_status or left and right paths must be provided")
  }

  # --- Step 3: Generate sync_status object if not provided ----
  if(is.null(sync_status)) {

    # Validate that both left and right paths exist
    stopifnot(exprs = {
      fs::dir_exists(left_path)
      fs::dir_exists(right_path)
    })

    # Generate sync_status by comparing the two directories
    sync_status <- compare_directories(left_path  = left_path,
                                       right_path = right_path,
                                       by_date    = by_date,
                                       by_content = by_content,
                                       recurse    = recurse,
                                       verbose    = FALSE
    )
  } else {

    # If sync_status is already available, retrieve the paths and options from it
    left_path  <- sync_status$left_path
    right_path <- sync_status$right_path

    # Assign options based on sync_status (if available)
    by_date    <- fifelse(is.null(sync_status$common_files$is_new_right),
                           FALSE,
                           by_date)
    by_content <- fifelse(!(is.null(sync_status$common_files$is_diff)),
                          TRUE,
                          by_content)
  }

  # --- Step 4: Backup if requested ----
  if (backup) {
    # Determine where to store backup (temporary directory if not specified)
    backup_dir <- fifelse(backup_dir == "temp_dir", 
                          file.path(tempdir(), "backup_directory"),
                          backup_dir)

    # Create the backup directory if it doesn't exist
    if (!dir.exists(backup_dir)) {
      dir.create(backup_dir, recursive = TRUE)
    }

    # Copy the contents of the right directory to the backup location
    file.copy(from      = right_path,
              to        = backup_dir,
              recursive = TRUE)
  }

  # --- Step 5: Identify files to copy, delete, or move ----

  # Files to copy from common files based on the sync criteria (date/content)
  files_to_copy <- sync_status$common_files |>
    filter_common_files(by_date    = by_date,
                        by_content = by_content,
                        dir = "left")

  # Add files only in the left directory (non-common files)
  files_to_copy <- files_to_copy |>
    rowbind(
      filter_non_common_files(sync_status$non_common_files,
                              dir = "left")
    )

  # Files to delete from the right directory (exclusive to right)
  files_to_delete <- sync_status$non_common_files |>
    filter_non_common_files(dir = "right") |>
    fselect(path_right)

  # --- Step 6: Preview synchronization if force = FALSE ----
  if (force == FALSE) {

    # Display files that will be deleted from the right directory
    if (nrow(files_to_delete) > 0 ) {
      style_msgs("orange",
                 text = "These files will be DELETED in right")

      display_file_actions(path_to_files = files_to_delete,
                           directory     = right_path,
                           action        = "delete"
      )
    }

    # Display files that will be copied to the right directory
    if (nrow(files_to_copy) > 0 ) {
      style_msgs("blue",
                 text = "These files will be COPIED (overwriting if present) to right \n")
      display_file_actions(path_to_files = files_to_copy |> fselect(1),
                           directory     = left_path,
                           action        = "copy"
      )
    }

    # Ask for user confirmation to proceed with synchronization
    Ask <- askYesNo(msg     = "Do you want to proceed? Type your answer",
                    default = TRUE,
                    prompts = c("Yes", "No", "Cancel"))

    # Abort if the user does not agree
    if (Ask == FALSE | is.na(Ask)) {
      cli::cli_abort(message = "Synchronization interrupted. No action taken on directories")
    }
  }

  # --- Step 7: Perform synchronization ----
  ## Copy files from left to right
  copy_files_to_right(left_dir      = sync_status$left_path,
                      right_dir     = sync_status$right_path,
                      files_to_copy = files_to_copy,
                      recurse       = recurse)

  ## Delete files from the right directory
  fs::file_delete(files_to_delete$path_right)

  # --- Step 8: Display directory structure after synchronization ----
  if(verbose == TRUE) {

    style_msgs(color_name = "blue",
               text = "Directories structure AFTER synchronization:\n")
    display_dir_tree(path_left  = left_path,
                     path_right = right_path)

  }

  # --- Final message indicating success ----
  style_msgs(color_name = "green",
             text = paste0("\u2714", " synchronized\n"))

  # Return invisible TRUE indicating successful synchronization
  invisible(TRUE)

}

```

## Output

### Installation

To install {syncdr} from GitHub, use:

```{r installation}
#devtools::install_github("RossanaTat/syncdr")

```

Given that I have {syncdr} already installed, I load it directly

```{r }
library(syncdr)
```

### Usage Example

#### Setup: Creating Toy Directories

To illustrate how {syncdr} works, we'll generate example directories:

```{r setup}

# Load {syncdr}
library(syncdr)

# Create toy directories and initialize .syncdrenv
.syncdrenv <- toy_dirs()

# Extract paths to left and right directories
left  <- .syncdrenv$left
right <- .syncdrenv$right

# Display directory structures
display_dir_tree(path_left  = left,
                 path_right = right)


```

*Step 1: Compare Directory Synchronization Status*

First check the differences between the two directories, by date of modification

```{r comp}
compare_directories(left_path  = left,
                    right_path = right)

# Save it in an object for further use 
sync_status <- compare_directories(left_path  = left,
                                   right_path = right)
```

*Step 2: Visualize directories' structure*

```{r vis}

display_sync_status(sync_status$common_files,
                    left_path  = left,
                    right_path = right)

```

*Step 3: Perform Synchronization*

Perform an asymmetric synchronization from left to right. This means you have a master/leader directory (left), and you want changes made there to be reflected in a secondary/follower directory (right).

```{r}
full_asym_sync_to_right(left_path   = left,
                         right_path = right,
                         force      = FALSE)

```

## Additional comments

I believe this script to be a good representation of coding that adheres to highest standards of quality: it is built upon lower-level functions that handle file metadata extraction, content hashing, and data joins, making the back-end well structured while ensuring clear, user-friendly output. Also, the functions provide detailed documentation and customization options, allowing users to tailor the comparison process while maintaining clarity on the actions being performed. With built-in messaging and verbosity controls, users remain informed throughout execution. The script reflects strong attention to detail, balancing efficiency with usability, and is part of a broader effort to improve the back-end pipeline of the Poverty and Inequality Platform (PIP). Its structure also make it easy to extend and adapt for future modifications with other developers in a continuous development environment.
