---
title: "Introduction to {syncdr}"
format: html
author: "Rossana Tatulli"
date: "2025-02-17"
editor: visual
---

# ET Consultant Application - Development Indicators and Data (DECID)

## Coding sample

```{r, eval=FALSE}

#' Compare Two Directories for Synchronization Status
#'
#' This function compares two directories, typically referred to as 'left' and 'right', to determine their synchronization status at the file level.
#' The primary goal is to identify the synchronization status of files present in both directories and those exclusive to either directory.
#'
#'
#' @section Sync Status Types:
#' The synchronization status is determined for files present in both directories, as well as for files exclusive to either directory.
#' It can be computed based on modification date only, content only, or both.
#'
#' For Common Files:
#' * When comparing by date: 'new', 'old', or 'same'.
#' * When comparing by date and content: 'new and different', 'new and same', 'old and different', 'old and same', 'same and different', or 'same and same'.
#' * When comparing by content only: 'different' or 'same'.
#'
#' For Non-Common Files:
#' * When comparing by date (or by date and content, or by content only): 'only in left' or 'only in right'.
#'
#' @param left_path Path to the left/first directory.
#' @param right_path Path to the right/second directory.
#' @param by_date Logical. If TRUE (default), compares directories based on the modification date of common files.
#' @param by_content Logical. If TRUE, compares directories based on the hashed content of common files. Default is FALSE
#' @param recurse If TRUE, fully recurses through subdirectories. If a positive integer, specifies the number of levels to recurse.
#' @param verbose Logical. If TRUE display additional info on the comparison process. Default is FALSE
#'
#' @return A list of class "syncdr_status" containing the following elements:
#'   - Non-common files: Paths and synchronization status of files exclusive to either directory.
#'   - Common files: Paths and synchronization status of files present in both directories.
#'   - Path of the left directory.
#'   - Path of the right directory.
#'
#' @export
#' @examples
#' # Compare directories with 'compare_directories()'
#' e <- toy_dirs()
#'
#' # Get left and right directories' paths
#' left  <- e$left
#' right <- e$right
#' compare_directories(left, right)
#' # Compare by date and content
#' compare_directories(left, right, by_content = TRUE)
#' # Compare by content only
#' compare_directories(left, right, by_content = TRUE, by_date = FALSE)
compare_directories <- function(left_path,
                                right_path,
                                recurse     = TRUE,
                                by_date     = TRUE,
                                by_content  = FALSE,
                                verbose     = getOption("syncdr.verbose")){

  # Ensure both directory paths exist
  stopifnot(exprs = {
    fs::dir_exists(left_path)
    fs::dir_exists(right_path)
  })

  # Retrieve file information for the left directory
  info_left <- directory_info(dir     = left_path,
                              recurse = recurse)

  # Retrieve file information for the right directory
  info_right <- directory_info(dir     = right_path,
                               recurse = recurse)

  # Merge directory information using a full join to retain all files
  join_info <- joyn::joyn(x                = info_left,
                          y                = info_right,
                          by               = "wo_root",  # Match files based on relative path
                          keep_common_vars = TRUE,
                          suffixes         = c("_left", "_right"),
                          match_type       = "1:1",  # Ensures one-to-one matches
                          reportvar        = ".joyn", # Column indicating match status
                          verbose          = FALSE)

  # Identify files that exist only in one of the directories
  non_common_files <- join_info |>
    fsubset(.joyn == "y" | .joyn == "x") |>  # Select unmatched files
    fselect(path_left, path_right) |>         # Keep relevant columns
    ftransform(sync_status = ifelse(          # Assign sync status
      (is.na(path_left) & !is.na(path_right)), "only in right",
      "only in left")
    )

  # Identify files that exist in both directories
  common_files <- join_info |>
    fsubset(.joyn == "x & y") |>  # Select matched files
    fselect(path_left,
            path_right,
            modification_time_left,
            modification_time_right)  # Keep modification times

  # Compare modification times if requested
  if (by_date) {
    compared_times <- compare_modification_times(common_files$modification_time_left,
                                                 common_files$modification_time_right)
    common_files   <- cbind(common_files,
                            compared_times) |>
      ftransform(sync_status      = sync_status_date,  # Update sync status based on dates
                 sync_status_date = NULL)
  }

  # Compare file contents if requested
  if (by_content) {

    # If comparing by date, first filter files marked as new
    if (by_date) {
      common_files <- common_files |>
        fsubset(is_new_left == TRUE | is_new_right == TRUE)
    }

    # Compare file contents
    compared_contents <- compare_file_contents(common_files$path_left,
                                               common_files$path_right,
                                               verbose = verbose)

    common_files <- cbind(common_files,
                          compared_contents) |>
      ftransform(sync_status         = sync_status_content,  # Update sync status based on content
                 sync_status_content = NULL)
  }

  # Create a structured output list
  sync_status = list(
    common_files     = common_files,  # Files that exist in both directories
    non_common_files = non_common_files,  # Files unique to one directory
    left_path        = left_path,  # Path to left directory
    right_path       = right_path  # Path to right directory
  )

  # Display directory structure if verbose mode is enabled
  if (verbose) {
    display_dir_tree(left_path,
                     right_path)
  }

  # Assign custom class for easier handling in other functions
  class(sync_status) <- "syncdr_status"

  return(sync_status)
}



```

```{r, eval=FALSE}

#' Display status of synchronization/comparison info between two directories in DT table
#'
#' @param sync_status_files object of `compare_directories()` output, either common_files or non_common_files
#' @param left_path A character string specifying the path to left directory.
#' @param right_path A character string specifying the path to right directory.
#' @return DT table showing the comparison between the two directories
#'         together with their synchronization status
#' @export
display_sync_status <- function(sync_status_files,
                                left_path,
                                right_path) {

  # clean display of paths
  sync_status_files <- sync_status_files |>
    fmutate(path_left = gsub(left_path, "", path_left)) |>
    fmutate(path_right = gsub(right_path, "", path_right))

  # Build DT table
  DT::datatable(sync_status_files,
                options = list(
                  pageLength = 10, # number of rows to display per page
                  columnDefs = list(
                    list(targets = grep("^is_", colnames(sync_status_files), value = TRUE),
                         createdCell = DT::JS(
                           "function(td, cellData, rowData, row, col) {
                            if (cellData === true) {
                              $(td).css({'background-color': '#F8F4FF'});
                            } else {
                              $(td).css({'background-color': '#F0F8FF'});
                            }
                          }"
                         )
                    ),
                    list(targets = grep("sync_status", colnames(sync_status_files), value = TRUE),
                         createdCell = DT::JS(
                           "function(td, cellData, rowData, row, col) {
                             if (cellData.includes('different content') ||
                                 cellData.includes('same date') ||
                                 cellData.includes('only in right')) {
                              $(td).css({'background-color': '#a9def9'});
                            } else {
                              $(td).css({'background-color': '#e4c1f9'});
                            }
                          }"
                         )
                    )
                  )
                )
  )

}

```


```{r, eval=FALSE}

#' Full symmetric synchronization
#'
#' This function updates directories in the following way:
#' * For common files:
#'   - if by date: If the file in one directory is newer than the corresponding file in the other directory,
#'                 it will be copied over to update the older version. If modification dates are the same, no action is taken
#'   - if by date and content: If the file in one directory is newer AND different than the corresponding file in the other directory,
#'                             it will be copied over to update the older version. If modification dates/contents are the same, no action is taken
#'   - if by content only: this option is not active
#' * For non common files:
#'   - if a file exists in one but not in the other it is copied to the other directory
#'
#' @param left_path Path to the left/first directory.
#' @param right_path Path to the right/second directory.
#' @param sync_status Object of class "syncdr_status", output of `compare_directories()`.
#' @param by_date logical, TRUE by default
#' @param by_content logical, FALSE by default
#' @param recurse logical, TRUE by default.
#'  If recurse is TRUE: when copying a file from source folder to destination folder, the file will be copied into the corresponding (sub)directory.
#'  If the sub(directory) where the file is located does not exist in destination folder (or you are not sure), set recurse to FALSE,
#'  and the file will be copied at the top level
#' @param force Logical. If TRUE (by default), directly perform synchronization of the directories.
#'                       If FALSE, displays a preview of actions and prompts the user for confirmation before proceeding. Synchronization is aborted if the user does not agree.
#' @param backup Logical. If TRUE, creates a backup of the right directory before synchronization. The backup is stored in the location specified by `backup_dir`.
#' @param backup_dir Path to the directory where the backup of the original right directory will be stored. If not specified, the backup is stored in temporary directory (`tempdir`).
#' @param verbose logical. If TRUE, display directory tree before and after synchronization. Default is FALSE
#' @return Invisible TRUE indicating successful synchronization.
#' @export
#' @examples
#' # Create syncdr environment with toy directories
#' e <- toy_dirs()
#'
#' # Get left and right directories' paths
#' left  <- e$left
#' right <- e$right
#'
#' # Synchronize directories, e.g., by date and content
#' # Option 1 - providing left and right paths
#' full_symmetric_sync(left_path  = left,
#'                     right_path = right,
#'                     by_date    = TRUE,
#'                     by_content = TRUE)
#' # Option 2 - Providing sync_status object
#' sync_status = compare_directories(left_path  = left,
#'                                   right_path = right)
#' full_symmetric_sync(sync_status = sync_status)
full_symmetric_sync <- function(left_path   = NULL,
                                right_path  = NULL,
                                sync_status = NULL,
                                by_date     = TRUE,
                                by_content  = FALSE,
                                recurse     = TRUE,
                                force       = TRUE,
                                backup      = FALSE,
                                backup_dir  = "temp_dir",
                                verbose     = getOption("syncdr.verbose")) {
  if (verbose == TRUE) {
    # Display the directory structure before synchronization
    style_msgs(color_name = "blue",
               text       = "Directories structure BEFORE synchronization:\n")
    display_dir_tree(path_left  = left_path,
                     path_right = right_path)
  }

  # --- Validate input arguments ---

  # Ensure that either:
  # 1. Both left_path and right_path are provided, and sync_status is NULL
  # 2. sync_status is provided, and left_path and right_path are NULL
  if (!(
    is.null(sync_status) && !is.null(left_path) && !is.null(right_path) ||
    !is.null(sync_status) && is.null(left_path) && is.null(right_path)
  )) {
    style_msgs(color_name = "purple",
               text       = "Incorrect arguments specification!\n")
    cli::cli_abort("Either sync_status or left and right paths must be provided")
  }

  # --- Retrieve or generate sync_status ---

  if (is.null(sync_status)) {
    # Validate that the provided directory paths exist
    stopifnot(exprs = {
      fs::dir_exists(left_path)
      fs::dir_exists(right_path)
    })

    # Generate sync_status by comparing the two directories
    sync_status <- compare_directories(left_path  = left_path,
                                       right_path = right_path,
                                       by_date    = by_date,
                                       by_content = by_content,
                                       recurse    = recurse,
                                       verbose    = FALSE)
  } else {
    # Extract synchronization parameters from sync_status
    left_path  <- sync_status$left_path
    right_path <- sync_status$right_path

    # Determine whether to compare by date or content
    by_date    <- fifelse(is.null(sync_status$common_files$is_new_right),
                          FALSE,
                          by_date)
    by_content <- fifelse(!(is.null(sync_status$common_files$is_diff)),
                          TRUE,
                          by_content)
  }

  # --- Identify files for synchronization ---

  # Files to copy from left to right:
  files_to_right <- sync_status$common_files |>
    filter_common_files(by_date    = by_date,
                        by_content = by_content,
                        dir = "left") |>
    rowbind(
      filter_non_common_files(sync_status$non_common_files,
                              dir = "left")
    )

  # Files to copy from right to left:
  files_to_left <- sync_status$common_files |>
    filter_common_files(by_date    = by_date,
                        by_content = by_content,
                        dir = "right") |>
    rowbind(
      filter_non_common_files(sync_status$non_common_files,
                              dir = "right")
    )

  # --- User confirmation (if force = FALSE) ---

  if (force == FALSE) {
    if (nrow(files_to_right) > 0) {
      style_msgs("blue",
                 text = "These files will be COPIED (overwriting if present) to RIGHT \n")
      display_file_actions(path_to_files = files_to_right |> fselect(1),
                           directory     = left_path,
                           action        = "copy")
    }

    if (nrow(files_to_left) > 0) {
      style_msgs("blue",
                 text = "These files will be COPIED (overwriting if present) to LEFT \n")
      display_file_actions(path_to_files = files_to_left |> fselect(2),
                           directory     = right_path,
                           action        = "copy")
    }

    # Ask the user for confirmation before proceeding
    Ask <- askYesNo(msg     = "Do you want to proceed? Type your answer",
                    default = TRUE,
                    prompts = c("Yes", "No", "Cancel"))

    if (Ask == FALSE | is.na(Ask)) {
      cli::cli_abort("Synchronization interrupted. No action taken on directories")
    }
  }

  # --- Backup directories (if enabled) ---

  if (backup) {
    backup_right <- fifelse(backup_dir == "temp_dir",
                            file.path(tempdir(), "backup_right"),
                            backup_dir)
    backup_left <- fifelse(backup_dir == "temp_dir",
                           file.path(tempdir(), "backup_left"),
                           backup_dir)

    # Create backup directories if they don't exist
    if (!dir.exists(backup_right)) {
      dir.create(backup_right, recursive = TRUE)
    }
    if (!dir.exists(backup_left)) {
      dir.create(backup_left, recursive = TRUE)
    }

    # Copy the contents of both directories to the backup locations
    file.copy(from = right_path, to = backup_right, recursive = TRUE)
    file.copy(from = left_path, to = backup_left, recursive = TRUE)
  }

  # --- Handle case where sync by content only is not active ---
  if (by_date == FALSE & by_content == TRUE) {
    cli::cli_abort("Symmetric synchronization by content only is not active - no action will be executed, directories unchanged")
  }

  # --- Perform the synchronization ---

  # Copy files from left to right directory
  copy_files_to_right(left_dir      = sync_status$left_path,
                      right_dir     = sync_status$right_path,
                      files_to_copy = files_to_right)

  # Copy files from right to left directory
  copy_files_to_left(left_dir      = sync_status$left_path,
                     right_dir     = sync_status$right_path,
                     files_to_copy = files_to_left,
                     recurse       = recurse)

  if (verbose == TRUE) {
    # Display the directory structure after synchronization
    style_msgs(color_name = "blue",
               text       = "Directories structure AFTER synchronization:\n")
    display_dir_tree(path_left  = left_path,
                     path_right = right_path)
  }

  # Indicate that synchronization was successful
  style_msgs(color_name = "green",
             text       = paste0("\u2714", " synchronized\n"))

  invisible(TRUE)
}



```



## Output

This document provides a short version overview of the {syncdr} R package, demonstrating some of its key functionalities for synchronizing directories. {syncdr} offers a range of tools for managing file synchronization efficiently â€”this is just a small preview.\
Since the code in the sample comes from an R package and isn't runnable on its own, this section serves as a practical example to showcase the functions in action without requiring you to run it yourself. For more details For more details, visit the [official {syncdr} website](https://rossanatat.github.io/syncdr/).

### Installation

To install {syncdr} from GitHub, use:

```{r installation}
#devtools::install_github("RossanaTat/syncdr")

```

```{r loading}
library(syncdr)
```

### Usage Example

#### Setup: Creating Toy Directories

To illustrate how {syncdr} works, we'll generate example directories:

```{r setup}

# Load {syncdr}
library(syncdr)

# Create toy directories and initialize .syncdrenv
.syncdrenv <- toy_dirs()

# Extract paths to left and right directories
left  <- .syncdrenv$left
right <- .syncdrenv$right

# Display directory structures
display_dir_tree(path_left  = left,
                 path_right = right)


```

*Step 1: Compare Directory Synchronization Status*

We first check the differences between the two directories:

```{r}
compare_directories(left_path  = left,
                    right_path = right)
```

*Step 2: Perform Synchronization*

Now, we perform an asymmetric synchronization from left to right. This means files present in the left directory but missing in the right will be copied over, without modifying files in the left directory:

```{r}
full_asym_sync_to_right(left_path   = left,
                         right_path = right,
                         force      = FALSE)

```

## Additional comments
I believe this script is a good representation of coding that adheres to highest standards of quality: it is structured with lower-level functions that handle file metadata extraction, content hashing, and structured joins, making the backend complex but ensuring clear, user-friendly output. Also, the functions provide detailed, well-structured documentation and customizable options, allowing users to tailor the comparison process while maintaining clarity on the actions being performed. With built-in messaging and verbosity controls, users remain informed throughout execution. The script reflects strong attention to detail, balancing efficiency with usability, and is part of a broader effort to improve the backend pipeline of the Poverty and Inequality Platform (PIP). Its modularity and clarity also make it easy to extend and adapt for future development with other developers in a continuous development environment. 